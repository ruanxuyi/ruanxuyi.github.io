title: "LintCode92 - Backpack"
date: 2018-01-17 14:57:07
tags:
- LintCode
- DP
---


## <center> description </center>

http://www.lintcode.com/en/problem/backpack/

Given `n` items with size $A_i$, an integer `m` denotes the size of a backpack. How full you can fill this backpack?

If we have 4 items with size `[2, 3, 5, 7]`, the backpack size is `11`, we can select `[2, 3, 5]`, so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select `[2, 3, 7]` so that we can fulfill the backpack.

You function should return the max size we can fill in the given backpack.

## <center> code </center>

```java
public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    public int backPack(int m, int[] A) {
        // write your code here
        if (A == null || A.length == 0 || m == 0) {
            return 0;
        }
        
        int[][] dp = new int[A.length+1][m+1];
        
        // initialization
        // for (int i = 0; i < m+1; i++) {
        //     dp[0][i] = 0;
        // }
        
        // function
        for (int i = 1; i < A.length+1; i++) {
            for (int j = 0; j < m+1; j++) {
                if (j < A[i-1]) {
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = Math.max(A[i-1] + dp[i-1][j-A[i-1]], dp[i-1][j]);
                }
            }
        }
        
        // solution
        return dp[A.length][m];
    }
}
```

<!--more-->

## <center> algorithm </center>

When size of backpack (`j`) is smaller than current item size `A[i-1]`:  

```java
	dp[i][j] = dp[i-1][j];
```

`dp[i][j]` takes value of previous item of same backpack size `j`  

When size of backpack (`j`) is larger than or equal to current item size `A[i-1]`:  

```java
	dp[i][j] = Math.max(A[i-1] + dp[i-1][j-A[i-1]], dp[i-1][j]);
```
where `A[i-1] + dp[i-1][j-A[i-1]]` takes current item and `dp[i-1][j]` when not taking it. We take the max of the two.  
  

## <center> complexity analysis </center>

Time: $O(mn)$   
Space: $O(mn)$  
where $n = A.length$

## <center> notes </center>

order of items in `int[] A` can be random, not need to be in specific order, any order will work since it is doing **combination** all items.  

## <center> application </center>
## <center> reference </center>

https://www.youtube.com/watch?v=8LusJS5-AGo
