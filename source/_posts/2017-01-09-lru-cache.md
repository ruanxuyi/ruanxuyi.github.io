title: "lru cache"
date: 2017-01-09 09:41:31
tags:
- LintCode
- DataStructure
- HashMap
- LinkedList
- LRU
- Cache
---


## <center> description </center>

[]()

## <center> code </center>

### LinkedList + HashMap enhanced Ver.

```java
public class Solution {
    class ListNode {
        int val;
        int key;
        ListNode next;
        ListNode prev;
        
        public ListNode (int val, int key) {
            this.val = val;
            this.key = key;
            this.next = null;
            this.prev = null;
        }
    }
    private int size = 0;
    private int capacity = 0;
    private ListNode head = new ListNode(-1, -1); // dummy node
    private ListNode tail = new ListNode(-1, -1); // dummy node
    private HashMap<Integer, ListNode> cache = new HashMap<Integer, ListNode>();
    
    // @param capacity, an integer
    public Solution(int capacity) {
        // write your code here
        this.capacity = capacity;
        tail.prev = head; // #
        head.next = tail; // #
    }

    // @return an integer
    public int get(int key) {
        // write your code here
        ListNode curr;
        if (cache.containsKey(key)) {
            curr = cache.get(key);
            // update linkedList
            remove(curr);
            moveToHead(curr);
            return curr.val;
        }
        return -1; // item not exisit in cache
    }

    // @param key, an integer
    // @param value, an integer
    // @return nothing
    public void set(int key, int value) {
        // write your code here
        
        ListNode curr;
        // check existing key
        if (cache.containsKey(key)) {
            curr = cache.get(key);
            curr.val = value;
            remove(curr);
            moveToHead(curr);
            
            cache.put(key, curr);
            return;
        }
        // add new element
        ListNode tmp = new ListNode(value, key);
        moveToHead(tmp);
        
        if (size == capacity) { // invalidate LRU element
            // remove from cache
            cache.remove(tail.prev.key);
            // remove from linked list
            tail.prev = tail.prev.prev;
            tail.prev.next = tail;
            
        }
        
        cache.put(key, tmp);
        
        size = size < capacity ? ++size : size; // size <= capacity
    }
    
    public void moveToHead(ListNode node) {
        node.next = head.next;
        head.next = node;
        head.next.next.prev = node;
        head.next.prev = head;
    }
    
    public void remove(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}
```

### LinkedList(w/ dummy) Ver.

```java
public class Solution {
    class ListNode {
        int key;
        int val;
        ListNode next;
        ListNode prev;
        
        public ListNode (int key, int val) {
            this.key = key;
            this.val = val;
            this.next = null;
            this.prev = null;
        }
    }
    private int size = 0;
    private int capacity = 0;
    private ListNode head = new ListNode(-1,-1); // dummy node
    private ListNode tail = new ListNode(-1,-1); // dummy node

    // @param capacity, an integer
    public Solution(int capacity) {
        // write your code here
        this.capacity = capacity;
        tail.prev = head; // #
        head.next = tail; // #
    }

    // @return an integer
    public int get(int key) {
        // write your code here
        ListNode curr = head;
        curr = curr.next;
        while (curr.key != -1) { // reach tail
            if (key == curr.key) { // found
                remove(curr);
                moveToHead(curr);
                return curr.val;
            }
            curr = curr.next;
        }
        return -1; // item not exisit in cache
    }

    // @param key, an integer
    // @param value, an integer
    // @return nothing
    public void set(int key, int value) {
        // write your code here
        
        ListNode curr = head;
        curr = curr.next;
        // check existing key
        while (curr.key != -1) { // reach tail
            if (key == curr.key) {
                curr.val = value;
                remove(curr);
                moveToHead(curr);
                return;
            }
            curr = curr.next;
        }
        // add new element
        ListNode tmp = new ListNode(key, value);
        moveToHead(tmp);
        
        if (size == capacity) {
            tail.prev = tail.prev.prev;
            tail.prev.next = tail;
        }
        size = size < capacity ? ++size : size; // size <= capacity
    }
    
    public void moveToHead(ListNode node) {
        node.next = head.next;
        head.next = node;
        head.next.next.prev = node;
        head.next.prev = head;
    }
    
    public void remove(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}
```

<!--more-->

### LinkedList(wo/dummy) Ver.

```java
public class Solution {
    class ListNode {
        int key;
        int val;
        ListNode next;
        ListNode prev;
        
        public ListNode (int key, int val) {
            this.key = key;
            this.val = val;
            this.next = null;
            this.prev = null;
        }
    }
    private int size = 0;
    private int capacity = 0;
    ListNode head;
    ListNode tail;
    
    // @param capacity, an integer
    public Solution(int capacity) {
        // write your code here
        this.capacity = capacity;
    }

    // @return an integer
    public int get(int key) {
        // write your code here
        ListNode curr = head;
        //System.out.println("get(" + key + ")");
        //System.out.println("head: " + head.key + ")");
        while (curr != null) {
            //System.out.println("key: " + curr.key);
            if (key == curr.key) {
                // curr == head
                if (curr.key == head.key) {
                    return head.val;
                }
                // move to head
                if (curr.prev != null) {
                    curr.prev.next = curr.next;
                }
                if (curr.next != null) {
                    curr.next.prev = curr.prev;
                }
                // if curr is tail, update tail
                if (curr.key == tail.key) {
                    tail = curr.prev;
                }
                curr.next = head;
                head.prev = curr;
                head = curr;
                //curr.prev = null;
                curr = null;
                return head.val;
            }
            curr = curr.next;
        }
        return -1;
    }

    // @param key, an integer
    // @param value, an integer
    // @return nothing
    public void set(int key, int value) {
        // write your code here
        if (size < capacity) {
            // space avalibable
            if (head == null) {
                head = new ListNode(key, value);
                tail = head;
            } else {
                ListNode tmp = new ListNode(key, value);
                tmp.next = head;
                head.prev = tmp;
                head = tmp;
            }
            size++;
        } else {
            // LRU invalidate
            tail = tail.prev;
            tail.next = null;
            ListNode tmp = new ListNode(key, value);
            tmp.next = head;
            head.prev = tmp;
            head = tmp;
        }
    }
}
```

## <center> algorithm </center>



### HashMap
- **add**  
$O(1)$ for fast adding element in hashmap
- **check**  
$O(1)$ for checking element already exist in hashmap `containsKey()`

- **locate** **LRU** **element**  
We can use additional variable `count` to record access count and return global min as the LRU element to invalidate. This require $O(capacity)$ time complexity.  

### Array
- **add**  
$O(1)$ fast adding, using `key` as array index. might need to store `count` to find LRU element to invalidate.  
- **check**  
$O(1)$ for checking element already exist in array  
- **locate** **LRU** **element** 
We can use additional variable `count` to record access count and return global min as the LRU element to invalidate. This require $O(capacity)$ time complexity.  

### LinkedList

The benefit of using `LinkedList` is there is **NO need** to traverse entire array to find out least recent used (LRU) element. Since finding the LRU element happen very frequently after we reach the cache capacity, we want an algorithm has low cost for finding the (LRU) element to invalidate.  

- **add**  
$O(1)$, `ListNode` instance stores `int key`, `int val`, w/ `ListNode prev` and `ListNode next`  
- **check**  
$O(capacity)$ to traverse entire linkedList.  
- **locate** **LRU** **element** 
$O(1)$ using `head`, and `tail` ListNode pointers to track LRU element. No need to traverse and compare `count` for LRU element.   

Always **add** new/update to the **front** of the LinkedList, and **tail** always point to the **LRU** element.  

**Dummy Node:**  
very helpful to eliminate processing of special case/boundary condition.  


## <center> complexity analysis </center>

### LinkedList + HashMap enhanced Ver.
- **Time**: $O(1)$  

Combine $O(1)$ for add/check operations from hashmap and $O(1)$ for locating LRU element from linkedlist.

- **Space**: $O(capacity)$  

cache size.

### LinkedList(w/ dummy) Ver.
- **Time**: $O(capacity)$  

Traverse entire linkedList for checking existing element to update in `set()` method, and same time complexity for `get()` method.  

- **Space**: $O(capacity)$  

cache size.

## <center> self notes </center>

## <center> application </center>

## <center> reference </center>
[九章sol](http://www.jiuzhang.com/solutions/lru-cache/)