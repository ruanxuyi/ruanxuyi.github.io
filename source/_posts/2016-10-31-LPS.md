title: "Longest Palindrome Subsequence"
date: 2016-10-31 14:29:13
tags:
- DP
- Palindrome
---

# <center> Description: </center>
**[Problem 15-2, p. 405 in 3rd edition]: 15-2 Longest palindrome subsequence**

![](http://7xihzu.com1.z0.glb.clouddn.com/2016001031/lps_backtrack.png)
A palindrome is a nonempty string over some alphabet that reads the same forward and backward. Examples of palindromes are all strings of length 1, `civic`, `racecar`, and `aibohphobia` (fear of palindromes).  
Give an efficient algorithm to find the **longest palindrome** that is a **subsequence** of a given input string. For example, given the input character, your algorithm should return carac. What is the running time of your algorithm?   


<!--more-->

# <center> Iterative approach: $O(2^n)$</center>

we can simply list out all the possible **subsequence** of a given string. However, the time complexity for that is exponential time $O(2^n)$, where N is the number of character in the string. 

> Note: for string `abc`, we have following subsequence: `a`, `b`, `c`, `ab`, `ac`, `bc`, `abc`. total $2^n -1$ subsequences. ($2^3 - 1 = 7$)

We can possiblely come up with a better algorithm that has much lower time complexity.  

> Note: be careful not to mix up substring with subsequence.  
> number of subsequence of a size `n` string = $2^n-1$  
> number of substring of a size `n` string = $n \times(n+1)\over2$  

[Godo aritcle on substring vs subsequence](http://www.geeksforgeeks.org/subarraysubstring-vs-subsequence-and-programs-to-generate-them/)  


# <center> DP approach: $O(n^2)$ </center>


## State
- 2D array `int[][] lps`  
- `lps[i][j]` stores number of LPS for substring of `str` from index `i` to `j`.  

ex. `str = "abcdcde"`, `lps[2][4] = 3` means for current string `str[2:4] = abcdc`, the number of longest palidrome subsequence is 3 (`cdc`).  

## Initialziation
- single character has size `1` of LPS.  

ex. for given `str = "abcdcde"`, `a`, `b`, `c`, `d` ... all has a LPS = 1. 

```java
	for (int i = 0; i < str.length(); i++) {
		lps[i][i] = 1;
	}
```

Result:  

```
  a|b|c|d|c|d|e|
a|1|0|0|0|0|0|0|
b|0|1|0|0|0|0|0|
c|0|0|1|0|0|0|0|
d|0|0|0|1|0|0|0|
c|0|0|0|0|1|0|0|
d|0|0|0|0|0|1|0|
e|0|0|0|0|0|0|1|
```

## Function
- DP approach trades space for time. ($O(2^n)$ -> $O(n^2)$)
- for subproblem at `lps[i][j]` we use following equation:  

if $str[i] == str[j]$ -> $lps[i][j] = lps[i+1][j-1] + 2 $  

else-> $lps[i][j] = Max(lps[i][j-1], lps[i+1][j])$


- If both characters are the same ($str[i] == str[j]$), we added 2 to the result.  

```
  0   1   2   3   4   5   6
_____________________________
| a | b | c | d | c | d | e |
-----------------------------
```
$str[2] == str[4]$, `lps[2][4] = lps[3][3] + 2`



- When $str[i] != str[j]$, we can find `lps[i][j]` by two seperate computations:   

```
  0   1   2   3   4   5   6
      |-----------|
______|___________|__________
| a | b | c | d | c | d | e |
--|------------|-------------
  |------------|
```

- When $str[0] != str[4]$,  
To find $lps[0][4]$ for string `"abcdc"`, we look for the maximum LPS from $lps[1][4]$ and $lps[0][3]$, (since we already computed values for $lps[1][4]$ and $lps[0][3]$ in the last iteration)  

> Note: string `"abcdc"` length 5 can be achieved by length 4 string **append** one character in either front/back of the length 4 string (either `"abcd"` $lps[0][3]$ or `"bcdc"` $lps[1][4]$). 

## Result
The function returns the max length of the LPS, but we can also easily track back the actual LPS sequence by looking at the 2d-matrices.


![](http://7xihzu.com1.z0.glb.clouddn.com/2016001031/lps_backtrack.png)


if `str.charAt(i) == str.charAt(j)`, diagonal cross -> `i++, j--`  
else choose route for the `max(lps[i][j-1], lps[i+1][j])`

LPS for String abcdcde is: "cdc" OR "dcd"


# <center> Source Code: </center>

```java
	private static int LPS_dp(String str) {
		// state
		int[][] lps = new int[str.length()][str.length()];
		// intialization, len = 1
		for (int i = 0; i < str.length(); i++) {
			lps[i][i] = 1;
		}
		printMatrices(lps, str);
		// function
		int len;
		for (len = 2; len <= str.length(); len++) {
			for (int i = 0, j = i + len - 1; j < str.length(); ++i, j = i + len - 1) {
				if (str.charAt(i) == str.charAt(j)) {
					lps[i][j] = lps[i+1][j-1] + 2;
				} else {
					lps[i][j] = Math.max(lps[i][j-1], lps[i+1][j]);
				}
			}
		}
		traceBackLPS(lps, str); // trace back to find LPS
		printMatrices(lps, str); // print dp matrices
		
		return lps[0][str.length()-1];
	}
```


[github](https://github.com/ruanxuyi/codings/blob/master/src/dp/LPS.java)

# <center> Reference: </center>

[Longest Palindromic Subsequence Graphical interperation](http://algorithms.tutorialhorizon.com/longest-palindromic-subsequence/)  
[Dynamic Programming | Set 12 (Longest Palindromic Subsequence)](http://www.geeksforgeeks.org/dynamic-programming-set-12-longest-palindromic-subsequence/)  
[Youtube Vedio Lecture](https://www.youtube.com/watch?v=_nCsPn7_OgI)

# <center> Logs: </center>
- 2016/10/31: initial post  



