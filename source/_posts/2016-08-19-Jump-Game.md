title: "LintCode 116 - Jump Game"
date: 2016-08-19 15:28:25
tags:
- LintCode
- DP
- Greedy
- H
---

[Jump Game](http://www.lintcode.com/en/problem/jump-game/#)

# Code: 

## V0 Greedy ($O(n)$)

```java 

public class Solution {
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    public boolean canJump(int[] A) {
        // wirte your code here
        if (A == null || A.length == 0) {
            return false;
        }
        int farDis = A[0];
        for (int i = 1; i < A.length && i <= farDis; i++) {
            if (A[i] + i > farDis) {
                farDis = A[i] + i;
            }
        }
        return farDis >= A.length - 1;
    }
}


```

## V1 DP ($O(n^2)$)

```java 

public class Solution {
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    public boolean canJump(int[] A) {
        // wirte your code here
        if (A == null || A.length == 0) {
            return false;
        }
        boolean[] com = new boolean[A.length];
        com[0] = true; // start point always reachable
        for (int i = 1; i < A.length; i++) { // start point already assigned
            for (int j = 0; j < i; j++) {
                if (com[j] && A[j] + j >= i) {
                    com[i] = true;
                    break;
                }
            }
        }
        return com[A.length - 1];
    }
}


```

<!--more-->

## V2: version that misunderstood the description
- this version use the number as exact distance jumped  

```java

public class Solution {
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    public boolean canJump(int[] A) {
        // wirte your code here
        if (A == null || A.length == 0) {
            return false;
        }
        int currIndex = A.length - 1;
        Queue<Integer> candiate = new LinkedList<Integer>();
        candiate.offer(currIndex);
        while (!candiate.isEmpty()) {
            currIndex = candiate.poll();
            if (currIndex == 0) {
                return true;
            }
            for (int i = 0; i < A.length; i++) {
                if (i + A[i] == currIndex || i - A[i] == currIndex) {
                    candiate.offer(i);
                }
            }
        }
        return false;
    }
}


```


# Description: 

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

> **Notice**

> This problem have two method which is `Greedy` and `Dynamic Programming`.

> The time complexity of `Greedy` method is `O(n)`.

> The time complexity of `Dynamic Programming` method is `O(n^2)`.

> We manually set the small data set to allow you pass the test in both ways. This is just to let you learn how to use this problem in dynamic programming ways. If you finish it in dynamic programming ways, you can try greedy method to make it accept again.


**Example**
> `A = [2,3,1,1,4]`, return `true`.

> `A = [3,2,1,0,4]`, return `false`.

# Thought Process:

## V0 Greddy

> Greedy Algorithm: Greedy Algorithm is the idea of finding the **local optimum** at  each stage with the hope of finding a **global optimum**.   

- record the farthest point (`farDis`) from start point.  
- from start point to `farDis` index can be reach, update the new `farDis` index base on current reachable range.  
- if `farDis` is larger or equal to `A.length - 1`, then the last index is reachable.  

## V1 DP

The array `com[i]` stores boolean value (`true` or `false`), which uses to represent whether or not we are able to jump to location `i`. And every update on the new location for `com[i]` depends on:   
- whether current postion `j` is reachable from start point `com[j]`, and  
- whether current examining postion `i` is reachable from any of the locations index before/pre to `i`. (If `A[j] + j >= i`, we can said that current examining postion `i` is reachable from postion `j`). Once we are able to determine the value for `com[i]`, no need to examine the rest element and we simply `break` the inner loop.

The notion of DP comes from we are using extra space $O(N)$ to store boolean value to indicate whether the postion is reachable from start postion.  
 

# Corner Case:
- A == null || A.length == 0  

# Reference: 

[Solution by Jiuzhang](http://www.jiuzhang.com/solutions/jump-game/)