title: "LC12 - Min Stack"
date: 2017-01-05 13:19:45
tags:
- LintCode
- SBNN
- Stack
- DataStructure
- HashMap
---

## <center> description </center>
Implement a stack with `min()` function, which will return the smallest number in the stack.

It should support push, pop and min operation all in $O(1)$ cost.

 **Notice**
min operation will never be called if there is no number in the stack.

**Example**

```
push(1)  
pop()   // return 1  
push(2)
push(3)
min()   // return 2
push(1)
min()   // return 1
```

[]()

## <center> code </center>
```java
public class MinStack {
    private HashMap<Integer, Integer> stack = new HashMap<Integer, Integer>();
    private HashMap<Integer, Integer> min = new HashMap<Integer, Integer>();
    private int minIndex = -1;
    private int currIndex = -1;
    
    public MinStack() {
        // do initialize if necessary
    }

    public void push(int number) {
        // write your code here
        stack.put(++currIndex, number);

        if (minIndex == -1 || number <= min.get(minIndex)) { // bug1: num <= min.get
            min.put(++minIndex, number);
        }
    }

    public int pop() {
        // write your code here
        if (stack.get(currIndex).equals(min.get(minIndex))) { // bug2: get return object, use .equals() instead of `==` to compare.
            minIndex--;
        }
        return stack.get(currIndex--);
    }

    public int min() {
        // write your code here
        return min.get(minIndex);
    }
}
```
<!--more-->

## <center> algorithm correctness </center>



This is an enhanced version of stack data structure where it also keeps track of current **min value** of stack. 

The most straight thinking is use normal stack operations `push()`, `pop()` and `min()` opeartion require to traverse the entire stack for the updated `min`. However, time complexity will increase to $O(n)$.  

The requirement for `push()`, `pop()`, and `min()` all complete in $O(1)$ time complexity.  

> **<减少时间>**复杂度最便捷的方法就是**<增加空间>**复杂度，很自然的我们想到“双栈法”。再维护一个最小数的栈，这样更新minIndex的操作我们可以通过最小数出栈的方式来搞定了。

The first data structure came in is HashMap becuase of both `put` and `get` methods are in $O(1)$ complexity. On **push**, we increment index and store it into hashmap and we decrement index on **pop**.   

We also need an additional HashMap to support `min()` function. 

Item is added into `min` hashmap only when:   
1.when `min` hashmap is empty (`index == -1`)  
2.when value pushed is **smaller** than the **current smallest** value in `min` hashmap (`number <= min.get(minIndex)` where `minIndex` stores index of current min).  

**Example1**:   
push(1), push(2), push(3), min() returns `1`  
`stack` = `[3,2,1]`  
`min` = `[1]`  
**Example2**:  
push(1), push(2), push(3), min() also returns `1`
`stack` = `[3,2,1]`  
`min` = `[3,2,1]`  

as we can see from two examples above:  
if min(`1`) is pushed before others(`2`, and `3`), `min` hashmap only need to **hold one item** and since `1` is the **last one to pop** (first pushed).

on the other hand, if min(`1`) is **not** the first pushed, `min` needs to stores other min values (`2` and `3`) to ensure correctness of `min()` after `1` is **popped**.

The requirement of `=` sign on line 15 is to prevent error on following test casse: `push(1), push(1), push(1), min(), pop(), min(), pop()`


## <center> complexity analysis </center>
**time**: time complexity for all operations are $O(1)$  
**space**: space complexity is $O(n+n) = O(n)$ at worst case when values are pushed in **decrement** order.  

[github]()

## <center> self notes </center>

**Note**: could use two stack instead, to **eliminate** the manual control of indices.  

## <center> application </center>


## <center> reference </center>
[ [LeetCode]Min Stack，解题报告](http://blog.csdn.net/wzy_1988/article/details/44016875)