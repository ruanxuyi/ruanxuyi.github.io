title: "N-Queens"
date: 2018-01-19 14:23:30
tags:
- LeetCode
- LintCode
- Recursion
---

## <center> description </center>

https://leetcode.com/problems/n-queens/description/  
http://lintcode.com/en/problem/n-queens/  

The n-queens puzzle is the problem of placing `n` queens on an $n√ón$ chessboard such that no two queens attack each other.

![](https://leetcode.com/static/images/problemset/8-queens.png)  
ref: image from leetcode  

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a **queen** and an **empty space** respectively.

For example,
There exist two distinct solutions to the 4-queens puzzle:

```
[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
```



## <center> code </center>

```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<List<String>>();
        helper(n, 0, new int[n], res);
        return res;
    }
    
    public static void helper(int n, int row, int[] colForRow, List<List<String>> res) {
        if (row == n) {
            // construct result string
            List<String> singleSolution = new ArrayList<String>();
            
            for (int i = 0; i < n; i++) {
                StringBuilder stringRow = new StringBuilder();
                for (int j = 0; j < n; j++) {
                    if (colForRow[i] == j) {
                        stringRow.append("Q");
                    } else {
                        stringRow.append(".");
                    }
                }
                singleSolution.add(stringRow.toString());
            }
            res.add(singleSolution);
        } else {
            // recursively find string
            for (int i = 0; i < n; i++) { // try to put queen on all cols of current row
                colForRow[row] = i; // queen's position
                if (check(row, colForRow)) {
                    helper(n, row+1, colForRow, res); // next row
                }
            }
        }
    }
    
    public static boolean check(int row, int[] colForRow) {
        for (int i = 0; i < row; i++) { // ensure no conflict w/ all current set rows
            if (colForRow[row] == colForRow[i] || // check vertical conflict
                Math.abs(colForRow[i] - colForRow[row]) == (row - i)) { // check diagonal conflict. Math.abs() for both 45 and 135 diagonal
                return false;
            }
        }
        return true;
    }
}
```

<!--more-->

## <center> algorithm </center>
- at each step, we check one row at a time (column-wise traversal also works)  
- for that row, we check all columns in that row and call `check()` function to ensure queen placement is valid  
- we check all rows **recursively** add up all possible solutions  

there are three possible types of attacking queen postions:   
- vertical attack: `colForRow[row] == colForRow[i]`  
- horizontal attack: not possible since we place **one** queen at a row  
- diagonal attack: `Math.abs(colForRow[i] - colForRow[row]) == (row - i))`   

![](http://7xihzu.com1.z0.glb.clouddn.com/20180119/8-queens-check-function.png)

`colForRow[i]` returns col number for row `i`. If `Math.abs(colForRow[i] - colForRow[row]) == (row - i))`, diagonal conflict detected, otherwise, diagonal conflict not detect.  


## <center> complexity analysis </center>

time: $O(n^3)$

`helper()` goes through total $O(n^2)$ cells and `check()` with $O(n)$ is performed in each cell.  

space: $O(n^2)$


## <center> notes </center>

## <center> application </center>

## <center> reference </center>

http://blog.csdn.net/linhuanmars/article/details/20667175
