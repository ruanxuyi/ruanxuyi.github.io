title: "LintCode 109 - Triangle"
date: 2016-08-09 11:55:24
tags:
- LintCode
- DP
- H
---

[Triangle](http://www.lintcode.com/en/problem/triangle/)

# V0 Code: Recursive version (NOT pass)

```java

public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        // write your code here
        int startRow = 0;
        int startCol = 0;
        return findMinPath(triangle, startRow, startCol);
    }
    private int findMinPath(int[][] triangle, int row, int col) {
        int height = triangle.length;
        if (row == height - 1) {
            return triangle[row][col];
        }
        int left = findMinPath(triangle, row+1, col);
        int right = findMinPath(triangle, row+1, col+1);
        return Math.min(left, right) + triangle[row][col];
    }
}

```

Recursive version works, however, it did not pass the test case where large number of data set was given.  


```
Your code ran too much time than we expected. Check your time complexity. Time limit exceeded usually caused by infinite loop if your time complexity is the best.

```

Reasoning behind slow run time for recursion, please refer to link below:  

[Recursion vs. Iteration](http://xuyiruan.com/2016/07/15/Recursion-vs-Iteration/) 

# V1 Code: Iteration version($O(N^2)$ extra space)

```java

public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        // write your code here
        int depth = triangle.length;
        int[][] minSum = new int[depth][depth];
        // initialize last row, buttom up
        for (int i = 0; i < triangle[depth-1].length; i++) {
            minSum[depth-1][i] = triangle[depth-1][i];
        }
        // loop through triangle from second last level from botton to top
        for (int i = depth-2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                int min = minSum[i+1][j];
                if (min > minSum[i+1][j+1]) {
                    min = minSum[i+1][j+1];
                }
                // update current/root @ i, j of minSum with min + triangle[i][j]
                minSum[i][j] = min + triangle[i][j];
            }
        }
        // return solution
        return minSum[0][0];
    }
}


```

<!--more-->

# V1 Code: Iteration version($O(N)$ extra space)

```java

public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        // write your code here
        int depth = triangle.length;
        int[] minSum = new int[depth];
        // initialize last row, buttom up
        for (int i = 0; i < triangle[depth-1].length; i++) {
            minSum[i] = triangle[depth-1][i];
        }
        // loop through triangle from second last level from botton to top
        for (int i = depth-2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                int min = minSum[j];
                if (min > minSum[j+1]) {
                    min = minSum[j+1];
                }
                // update current/root @ i, j of minSum with min + triangle[i][j]
                minSum[j] = min + triangle[i][j];
            }
        }
        // return solution
        return minSum[0];
    }
}

```





# Description: 
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.  

> **Notice**:  
> **Bonus** **point** if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.  

# Thought Process:

## Recursive Version (V0)
V0 version use recursive algorithm, even the implementation was correct, however, it it suffered in bad run time performance.  

## Iterative Version (V1) - $O(N^2)$ space
Instead of optimizing recursive algorithm, V1 version use iterative approach and pass the test in a relatively lower runtime (~1360ms).  

**Below is the algorithm for iterative approach:**  
- buttom up approach.  
- **idea of DP**: store minPathSum value from location`(i, j)` to leaf to `minSum[i][j]`  
- Sacrificing $(1/2)*n^2$ space, we could easily access minPathSum for any point in the triangle quickly without repeated computation. (Note: $O(N)$ space complexity version might not able to achieve this feature).  
- the iterative method prograte up until we get minPath value from top/root location $(0,0)$ to leaf, which will be stored at `minSum[0][0]`.  

## Iterative Version (V2) - $O(N)$ space

At each of the iteration, the value of minSum value of current level ONLY depends on the minSum value of the level below.  

In other word, to calculate the `minSum` value at location $(i, j)$, (@level i) we ONLY need to know the `minSum` value at `minSum[i+1][j]` and `minSum[i+1][j+1]` (@level i+1).  

Therefore, we can reduce the extra storage from 2D ($O(N^2)$ space) to 1D ($O(N)$ space).  

Since we initialize the 1D array `minSum[]` with length of the last level and we are using bottom up approach. No worry about index-out-of-bound issue.  

Another amazing detail about the `O(N)` approach: Since we are using the **same** array `minSum[]`, during the iterative update, the array may hold both minSum values from current level(n), and the value from level below(n+1).  

It elegantly updates new minSum values for level n, while the remaining minSum value from level n+1 still be able to participate in computation for remaining minSum value for level n.  



# Corner Case:

NA 

# Reference: 

[Blog: lintcode:Triangle](http://blog.csdn.net/gao1440156051/article/details/51107177)  


 