title: "LC4 - ugly num 2"
date: 2017-01-06 10:07:31
tags:
- LintCode
- DataStructure
---


## <center> description </center>
Ugly number is a number that only have **factors** `2`, `3` and `5`.

Design an algorithm to find the nth ugly number. The first 10 ugly numbers are `1, 2, 3, 4, 5, 6, 8, 9, 10, 12...`

 **Notice**  
Note that 1 is typically treated as an ugly number.

**Example**
If `n=9`, return `10`.

[LC4 ugly num 2](http://www.lintcode.com/en/problem/ugly-number-ii/)

## <center> code </center>

### 
```java
class Solution {
    /**
     * @param n an integer
     * @return the nth prime number as description.
     */
    public int nthUglyNumber(int n) {
        // Write your code here
        int[] uglyList = new int[n];
        uglyList[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i < n; i++) {
            int a2 = 2*uglyList[p2];
            int a3 = 3*uglyList[p3];
            int a5 = 5*uglyList[p5];
            
            int ugly_curr = Math.min(a2, Math.min(a3, a5));
            uglyList[i] = ugly_curr;
            // increment index the one choosen (like merge sort)
            if (a2 == uglyList[i]) p2++;
            if (a3 == uglyList[i]) p3++;
            if (a5 == uglyList[i]) p5++;
        }
        return uglyList[n-1];
    }
};
```

<!--more-->

### Recursive Ver. (worked but stack overflow) 
```java
class Solution {
    /**
     * @param n an integer
     * @return the nth prime number as description.
     */
    public int nthUglyNumber(int n) {
        // Write your code here
        int ugly = 0;
        int curr_index = 1;
        int offset = 0;
        
        while (ugly < n) {
            if(isUgly(curr_index) == true) {
                ugly++;
            } else {
                offset++;
            }
            curr_index++;
        }
        return n + offset;
    }
    boolean isUgly(int num) {
        if (num == 1 || num == 2 || num == 3 || num == 5) {
            return true;
        }
        return fact(num, 2) || fact(num, 3) || fact(num, 5);
    }
    boolean fact(int num, int div) {
        int remain = num % div;
        int res_div = num / div;
        if (remain == 0) {
            if (res_div <= 5) {
                return true;
            } else {
                return fact(res_div, 2) || fact(num, 3) || fact(num, 5);
            }
        }
        return false;
    }
};
```

## <center> algorithm </center>

first of all, lets review the definition of ugly number. Ugly numbers are number with only factor of `2, 3, and 5`. `1` is also considered a dirty number.  

The first five dirty numbers consisted of `1, 2, 3, 4, 5`, the **next** dirty numbers can be achieved by **combination** of **exisiting** dirty number with either `2, 3, or 5`. 

All existing ugly numbers store in `uglyList`.

For example, the `6th` dirty number is the combination of exisiting dirty number $2$ with $3$, where $2\times 3 = 6$.  

Below are the lists of all possible ugly numbers: we need to select the **smaller** from head of **three lists** and add it to the `uglyList` until we got the $n$ ugly number.  


```
ugly number w/ factor of 2 ([a2]):   1*2, 2*2, 3*2, 4*2, 5*2, 6*2, 8*2, 9*2 ... 
ugly number w/ factor of 3 ([a3]):   1*3, 2*3, 3*3, 4*3, 5*3, 6*3, 8*3, 9*3 ... 
ugly number w/ factor of 5 ([a5]):   1*5, 2*5, 3*5, 4*5, 5*5, 6*5, 8*5, 9*5 ... 
```

the corresponding index for that list (`p2`, `p3` or `p5`) **increments** after ugly  number choosen from that list. 

## <center> algorithm correctness </center>

The essential step to prove this algorithm work: 

```
            int a2 = 2*uglyList[p2];
            int a3 = 3*uglyList[p3];
            int a5 = 5*uglyList[p5];
```

`a2`, `a3`, and `a5` are the three **new valid** ugly number to be evaluate and about to be added to the exisiting list. We compare and choose the **smallest** of the three.  


In order to have valid `a2`, `a3`, and `a5`, we need to ensure existing ugly number `uglyList[p2]`, `uglyList[p3]`, and `uglyList[p5]` are valid.   

Since `p2`, `p3`, and `p5` initialized to `zero` at the begining. At each iteration, only one of the pointer will increment.  

`uglyList[0]` is always `1`. At the **fisrt iteration**, we need to add either `a2`, `a3`, or `a5` into `uglyList[1]`. Current index for `p2`, `p3`, and `p5` are all equal to `1`.   

After **first iteration**, `uglyList[1]` is valid and one of `p2`, `p3`, or `p5` will increment (ex. `p2=1`, `p3=0`, or `p5=0`). As long as index `p2`, `p3`, or `p5` returns valid value from `uglyList`, the algorithm works.   

Indeed that is truth, because, assume the worst case that `p2` always get increment (`p2` is the furthest index comapre to `p3`, `p5`). If `p2` the furthest index, returns a valid value, `uglyList[p2]`. Indice `p3` and `p5` should return valid value. Therefore, the algorithm works.  


## <center> complexity analysis </center>
**Time**: $O(n)$ for-loop need to traverse $n$ time to get the $n$th ugly number.  
**Space**: $O(n)$ array of size $n$ to store existing ugly numbers.  
[github]()

## <center> self notes </center>

## <center> application </center>
relate question on determine whether or not a number is a ulgy number.  
[LC517 Ugly Number](http://www.lintcode.com/en/problem/ugly-number/)

Very **elegant** solution, feel free to take a look!
## <center> reference </center>

[水中的鱼[Leetcode] Ugly Number II, Solution](http://fisherlei.blogspot.com/2015/10/leetcode-ugly-number-ii-solution.html)  
[九章 solution](http://www.jiuzhang.com/solutions/ugly-number-ii/)