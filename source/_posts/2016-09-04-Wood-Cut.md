title: "LintCode 183: Wood Cut"
date: 2016-09-04 14:23:27
tags:
- LintCode
- BinarySearch
---

[Wood Cut](http://www.lintcode.com/en/problem/wood-cut/)

# Code: 

```java

public class Solution {
    /** 
     *@param L: Given n pieces of wood with length L[i]
     *@param k: An integer
     *return: The maximum length of the small pieces.
     */
    public int woodCut(int[] L, int k) {
        // write your code here
        if (L.length == 0 || L == null || k < 0) {
            return 0;
        }
        int maxVal = 0;
        for (int i = 0; i < L.length; i++) {
            maxVal = Math.max(maxVal, L[i]);
        }
        int low = 1;
        int mid = 0;
        int high = maxVal;
        while (low + 1 < high) {
            mid = low + (high - low) / 2;
            if (count(L, mid) >= k) {
                low = mid;
            } else {
                high = mid;
            }
        }
        if (count(L, high) >= k) {
            return high;
        }
        if (count(L, low) >= k) {
            return low;
        }
        return 0;
    }
    private int count(int[] L, int len) {
        int count = 0;
        for (int i = 0; i < L.length; i++) {
            count += L[i] / len;
        }
        return count;
    }
}

```

<!--more-->

# First draft: 

```java

public class Solution {
    /** 
     *@param L: Given n pieces of wood with length L[i]
     *@param k: An integer
     *return: The maximum length of the small pieces.
     */
    public int woodCut(int[] L, int k) {
        // write your code here
        if (L.length == 0 || L == null || k < 0) {
            return -1;
        }
        int maxIndex = 0;
        for (int i = 0; i < L.length; i++) {
            if (L[i] > L[maxIndex]) {
                maxIndex = i;
            }
        }
        int low = 1;
        int mid = 0;
        int high = L[maxIndex];
        while (low + 1 < high) {
            mid = low + (high - low) / 2;
            int currK = 0;
            for (int i = 0; i < L.length; i++) {
                currK += L[i] / mid;
            }
            if (k < currK) {
                low = mid;
            } else if (k > currK) {
                high = mid;
            } else {
                return mid;
            }
        }
        return low;
    }
}

```

## Second draft (Passed)

```java

public class Solution {
    /** 
     *@param L: Given n pieces of wood with length L[i]
     *@param k: An integer
     *return: The maximum length of the small pieces.
     */
    public int woodCut(int[] L, int k) {
        // write your code here
        if (L.length == 0 || L == null || k < 0) {
            return 0;
        }
        int maxIndex = 0;
        for (int i = 0; i < L.length; i++) {
            if (L[i] > L[maxIndex]) {
                maxIndex = i;
            }
        }
        int low = 1;
        int mid = 0;
        int high = L[maxIndex];
        while (low + 1 < high) {
            mid = low + (high - low) / 2;
            if (count(L, mid) >= k) {
                low = mid;
            } else {
                high = mid;
            }
        }
        if (count(L, high) >= k) {
            return high;
        }
        if (count(L, low) >= k) {
            return low;
        }
        return 0;
    }
    private int count(int[] L, int len) {
        int count = 0;
        for (int i = 0; i < L.length; i++) {
            count += L[i] / len;
        }
        return count;
    }
}

```

# Description: 

Given n pieces of wood with length L[i] (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L & k, return the maximum length of the small pieces.

**Example**  
For `L=[232, 124, 456], k=7,` return `114`.

**Hint:**

`O(n log Len)`, where Len is the longest length of the wood.



# Thought Process:
- why we find the **max** value instead of the **min**?  

if the min value in the `L` array is 1. In this case, it will be likely impossible to meet the requirement to find the `maximum length`.  

- `if (count(L, mid) >= k) low = mid;` 

we need to continue narrow the range (`low = mid`) to find the `maximum length`. As the length getting larger, the number `currK` will become smaller and approach to `k`. The binary search approach will ultimately return the `maximum length` if the given condition met.  

# Corner Case:

